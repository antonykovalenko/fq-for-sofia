<a id="1"></a>

## Что такое CSS?

Как и `HTML`, `CSS` на самом деле не является языком программирования. Это не язык разметки - это язык таблицы стилей. Это означает, что он позволяет применять стили выборочно к элементам в документах `HTML`.

- [Что такое CSS: объясняем простыми словами](https://gb.ru/blog/chto-takoe-css/)

---

<a id="16"></a>

## Что означает CSS-селектор?

`CSS` селектор – это необходимый инструмент для оформления веб-страницы. Используя один или сразу несколько, можно точечно задать стилевое оформление нужного элемента.

- [CSS-селекторы: зачем нужны и как применять](https://gb.ru/blog/css-selektory/)

---

<a id="24"></a>

## Что такое специфичность селекторов?

Специфичность селекторов в `CSS` — это механизм, который определяет, какие стили будут применяться к элементам, когда несколько правил совпадают. Специфичность выражается в виде четырёхзначного числа от `0001` до `1000`.

- [Специфичность](https://developer.mozilla.org/ru/docs/Web/CSS/Specificity)
- [Специфичность. Как браузер решает, какие стили применять к элементу?](https://doka.guide/css/specificity/)

---

<a id="2"></a>

## Что такое white-space?

Свойство white-space позволяет сохранять пробелы и переносы строк.

У него есть два известных значения:

`white-space: normal` – обычное поведение
`white-space: pre` – текст ведёт себя, как будто оформлен в тег pre.
Но браузеры поддерживают и другие, которые также бывают очень полезны.

- [Свойство white-space](https://learn.javascript.ru/white-space)

---

<a id="3"></a>

## В чём главное преимущество white-space?

Свойство `CSS` `white-space` позволяет управлять отображением пробелов и переносов строк в тексте элементов. Его основное преимущество заключается в возможности точно контролировать поведение пробельных символов, что обеспечивает гибкость в форматировании текста.

---

<a id="4"></a>

## Что такое «reset» CSS и для чего он нужен?

`CSS Reset` — это набор стилей, предназначенных для обнуления или унификации стандартных стилей браузера для `HTML-элементов`. Разные браузеры применяют собственные стили по умолчанию, что может приводить к несовместимому отображению веб-страниц. Использование `CSS Reset` помогает устранить эти различия, обеспечивая единообразный внешний вид элементов на всех платформах.

Зачем нужен `CSS Reset`:

1. Унификация стилей: Сброс стилей приводит элементы к единому виду, устраняя различия между браузерами.

2. Предсказуемость: Обнуление стандартных стилей позволяет разработчику точно контролировать оформление элементов, не полагаясь на стили браузера.

3. Упрощение разработки: С единым базовым стилем легче создавать адаптивный и кросс-браузерный дизайн.

- [Сброс стилей vs нормализация стилей || reset.css vs normalize.css](https://www.youtube.com/watch?v=uRvMBL6_lQM)

---

<a id="5"></a>

## Что такое плавающие элементы (floats) и как они работают?

В CSS свойство `float` позволяет элементу "выплывать" из обычного потока документа и выравниваться по левой или правой стороне контейнера. При этом последующий текст и встроенные элементы обтекают его с противоположной стороны.

- [Плавающие элементы](https://ru.hexlet.io/courses/css-positioning/lessons/float/theory_unit)

---

<a id="6"></a>

## Какие вы знаете методы запрета обтекания (clearing) и какие где применяются?

В `CSS` для управления обтеканием элементов, выведенных из потока с помощью свойства `float`, применяются различные методы очистки (`clearing`). Эти методы предотвращают нежелательное обтекание плавающих элементов последующим содержимым и обеспечивают корректное отображение структуры страницы.

Основные методы очистки обтекания:

1. **Свойство `clear`**:

- Описание: Применяется к элементу, следующему за плавающим, чтобы предотвратить обтекание с определенной стороны.
- Значения:
  `left` — отменяет обтекание слева.
  `right` — отменяет обтекание справа.
  `both` — отменяет обтекание с обеих сторон.
- Применение: Используется, когда необходимо, чтобы элемент начинался ниже плавающих элементов, избегая их обтекания.

```css
<div style="float: left;">Плавающий элемент</div>
<div style="clear: both;">Элемент без обтекания</div>
```

2. **Метод `"clearfix"`**:

- Описание: Используется для очистки обтекания внутри родительского контейнера, содержащего плавающие элементы, чтобы он корректно охватывал их по высоте.
- Реализация: Создается псевдоэлемент ::after, который очищает обтекание.

```css
.clearfix::after {
  content: "";
  display: table;
  clear: both;
}
```

- Применение: Класс clearfix добавляется к родительскому элементу, содержащему плавающие дочерние элементы.

3. **Свойство `overflow`**:

- Описание: Установка значения hidden или auto для свойства overflow у родительского контейнера заставляет его учитывать размеры плавающих элементов.

```css
.container {
  overflow: hidden;
}
```

Применение: Используется для предотвращения схлопывания высоты родительского контейнера, содержащего плавающие элементы.

- [Float](https://developer.mozilla.org/ru/docs/Learn_web_development/Core/CSS_layout/Floats)
- [Очистка float](https://webref.ru/course/float/clearfix)
- [Решение проблемы переполнения контейнера с float в CSS](https://sky.pro/wiki/html/reshenie-problemy-perepolneniya-konteynera-s-float-v-css/)

---

<a id="7"></a>

## Что такое CSS спрайты?

`CSS-спрайт` – способ объединить много изображений в одно, чтобы:

1. Сократить количество обращений к серверу.
2. Загрузить несколько изображений сразу, включая те, которые понадобятся в будущем.
3. Если у изображений сходная палитра, то объединённое изображение будет меньше по размеру, чем совокупность исходных картинок.

- [CSS-спрайты](https://learn.javascript.ru/css-sprite)

---

<a id="8"></a>

## Как оптимизировать страницы для печати?

Оптимизация веб-страниц для печати с помощью `CSS` обеспечивает корректное отображение и удобочитаемость контента на бумаге. Основные шаги для достижения этого включают:

1. Подключение стилей для печати
2. Скрытие ненужных элементов
3. Обеспечение читабельности
4. Управление разрывами страниц
5. Настройка полей страницы
6. Удаление фона и теней
7. Тестирование и отладка
8. Использование абсолютных единиц измерения
9. Принудительная печать фона (при необходимости)

- [Инструкция: CSS-оптимизация веб-страницы для печати](https://vc.ru/flood/23660-print-style-sheets)

---

<a id="9"></a>

## Какие есть подводные камни в оптимизации производительности CSS?

Оптимизация производительности `CSS` играет ключевую роль в обеспечении быстрой загрузки и отзывчивости веб-страниц. Однако при внедрении оптимизационных техник важно учитывать возможные подводные камни, чтобы избежать непредвиденных проблем. Рассмотрим основные из них:

1. Минификация и сжатие `CSS`
2. Объединение файлов (`Concatenation`)
3. Использование современных технологий (`Flexbox` и `CSS Grid`)
4. Удаление неиспользуемого `CSS`
5. Использование `@import` вместо `<link>`
6. Избыточная специфичность селекторов
7. `CSS-анимации`
8. Отсутствие явного указания размеров элементов
9. Кэширование `CSS`

- [Подводные камни CSS и как с ними бороться](https://sitehere.ru/podvodnye-kamni-css-i-kak-s-nimi-borotsya)
- [7 советов по оптимизации CSS для ускорения загрузки страниц](https://habr.com/ru/articles/459878/)

---

<a id="10"></a>

## Как браузер определяет, на какие элементы накладывать CSS стили?

Браузер применяет `CSS`-стили к элементам веб-страницы, следуя определённому процессу, который включает несколько ключевых этапов:

1. Парсинг `HTML` и построение `DOM`-дерева:

При загрузке веб-страницы браузер анализирует `HTML`-код и строит из него `DOM` (`Document Object Model`) — иерархическую структуру, представляющую элементы и их взаимосвязи.

2. Сбор и анализ `CSS`:

Браузер собирает все связанные с `HTML` документом `CSS`-стили, включая встроенные стили, внешние таблицы стилей и стили, определённые с помощью атрибута `style`. Затем он анализирует эти стили, сортируя их по различным категориям, таким как элементы, классы и идентификаторы.

3. Формирование дерева рендеринга:

После анализа `CSS` и `HTML` браузер создаёт дерево рендеринга, которое сочетает информацию из `DOM` и `CSSOM` (`CSS Object Model`). Это дерево отражает структуру элементов с учётом применённых стилей и используется для визуализации страницы.

4. Применение стилей к элементам:

Браузер применяет стили к элементам, основываясь на их селекторах и специфичности. Стили могут быть определены непосредственно в HTML (встроенные стили), во внешних `CSS`-файлах или в атрибуте `style` каждого элемента. При наличии конфликтующих стилей браузер учитывает специфичность селекторов и порядок их определения, чтобы определить, какой стиль применить.

5. Отображение элементов:

После применения стилей браузер вычисляет окончательные значения стилей для каждого элемента и отображает их на экране, формируя визуальное представление веб-страницы.

Важно отметить, что каждый браузер может иметь свои особенности в интерпретации `CSS`, что может приводить к различиям в отображении элементов. Для обеспечения консистентности рекомендуется использовать фреймворки, такие как `Normalize.css`, которые помогают сгладить различия в стандартных стилях браузеров.

Понимание этого процесса позволяет разработчикам более эффективно управлять стилями и обеспечивать корректное отображение элементов на различных устройствах и браузерах.

---

<a id="11"></a>

## Что такое БЭМ?

`БЭМ` (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая `«Copy-Paste»`.

- [БЭМ документация](https://ru.bem.info/methodology/quick-start/)

---

<a id="12"></a>

## Каковы ограничения CSS?

Ограничения:

- Восхождение по селекторам невозможно
- Ограничения вертикального контроля
- Никаких выражений
- Нет объявления столбца
- Псевдокласс, не управляемый динамическим поведением
- Правила, стили, таргетинг на конкретный текст невозможны.

---

<a id="13"></a>

## Каковы преимущества CSS?

Преимущества:

- Пропускная способность
- Согласованность на уровне всего сайта
- Переформатирование страницы
- Универсальный доступ
- Содержание отделено от презентации

---

<a id="14"></a>

## Что такое CSS-фреймворки?

CSS-фреймворки — это предварительно подготовленные библиотеки кода, которые помогают быстро и согласованно реализовывать стилизацию и макеты веб-сайтов. Они содержат наборы стилей `CSS`, которые можно применять к элементам в веб-приложении после их подключения.

- [CSS фреймворки: что это такое и зачем они нужны?](https://frontendbase.ru/prodvinutye-tekhnologii/css-frejmvorki/)

---

<a id="15"></a>

## Сколькими способами можно интегрировать CSS в веб-страницу?

- [Как правильно подключить CSS к HTML](https://timeweb.com/ru/community/articles/kak-pravilno-podklyuchit-css-k-html)
- [Способы добавления стилей на страницу](https://htmlbook.ru/samcss/sposoby-dobavleniya-stiley-na-stranitsu)

---

<a id="17"></a>

## Что такое псевдоэлементы?

Псевдоэлементы в `CSS` — это специальные элементы, которых не существует в исходном HTML-коде. Поэтому они и называются «псевдо» — они как бы есть, но их как бы и нет. Чаще всего псевдоэлементы нужны для стилизации. Например, с помощью псевдоэлементов можно выделить первую букву абзаца, настроить отображение первой строки или наложить поверх картинки так называемый оверлей (перекрывающий слой).

- [Псевдоэлементы в CSS: что это и зачем они нужны](https://blog.skillfactory.ru/psevdoelementy-v-css-chto-eto-i-zachem-oni-nuzhny/)

---

<a id="18"></a>

## Как отменить подчеркивание гиперссылок?

```css
a.no-underline {
  text-decoration: none; /* Подчёркивания не будет */
}
```

---

<a id="19"></a>

## Каким способом я могу установить свойство opacity для элемента button, у которого есть атрибут disabled?

Через псевдокласс `:disabled`.

```css
button:disabled {
  opacity: 0.24;
}
```

---

<a id="20"></a>

## Как можно установить свойство opacity для элемента input, у которого установлен атрибут type со значением "radio"?

Чтобы отобрать элемент с `type="radio"` требуется использовать селекторы атрибутов.

```css
input[type="radio"] {
  opacity: 0.24;
}
```

---

<a id="21"></a>

## Что такое псевдокласс :root?

`:root` - селектор для выбора корневого элемента в `HTML` и `SVG`. Часто используют для кастомных свойств.

Псевдокласс `:root` нужен для обращения к самому главному родительскому элементу документа. Его также называют корневым элементом. В случае HTML-документа самым главным родителем всей страницы будет тег `<html>`. Часто `:root` используется для того, чтобы задавать кастомные свойства.

- [:root](https://doka.guide/css/root/)

---

<a id="22"></a>

## Как работает псевдокласс :placeholder-shown?

Псевдокласс `:placeholder-shown` срабатывает, когда у элементов `input` или `textarea` отображается `placeholder`. Если пользователь начинает ввод текста, то `placeholder` скрывается, и поэтому псевдокласс `:placeholder-shown` не применяется.

```css
input:placeholder-shown {
  background-color: lightgray;
}
```

---

<a id="23"></a>

## Как я могу задать CSS для элемента, в котором есть элемент, находящийся в фокусе?

Через псевдокласс `:focus-within`.

```html
<div class="some-parent">
  <button type="button">Some button</button>
</div>
```

```css
.some-parent:focus-within {
  outline: 2px solid purple;
  outline-offset: 5px;
}
```

---

<a id="25"></a>

## Единица измерения rem вычисляется в зависимости от значение какого свойства?

<details>
<summary>Ответ</summary>

`font-size`

</details>

---

<a id="26"></a>

## Как браузер расположит элементы div?

```html
<body>
  <div>element 1</div>
  <div>element 2</div>
</body>
```

<details>
<summary>Ответ</summary>

Элементы `div` являются блочными элементами по умолчанию, поэтому они будут расположены друг под другом в колонку.

</details>

---

<a id="27"></a>

## Как рассчитывается значение свойства height у блочных элементов?

Значение свойства `height` у блочных элементов рассчитывается в зависимости от высоты содержимого этого элемента.

---

<a id="28"></a>

## Размеры элемента .child — 196x196px. Да или нет?

```html
<body>
  <span class="child">element</span>
</body>
```

```css
.child {
  width: 196px;
  height: 196px;
}
```

<details>
<summary>Ответ</summary>

Нет, потому что значения свойств `width` и `height` у строчных элементов рассчитываются в зависимости от содержимого, и не могут быть изменены.

</details>

---

<a id="29"></a>

## Чему равняется высота элемента .parent

```html
<body>
  <div class="parent">
    <div class="child">element 2</div>
  </div>
</body>
```

```css
.child {
  position: absolute;
}
```

<details>
<summary>Ответ</summary>

Абсолютно-позиционированные элементы удаляются из потока документа, поэтому перестают влиять на родительский и соседние элементы. Соответственно, в нашем случает высота элемента `.parent` равняется нулю.

</details>

---

<a id="30"></a>

## Какие размеры у элемента span?

```css
span {
  width: 300px;
  height: 300px;
  position: absolute;
}
```

<details>
<summary>Ответ</summary>

`300x300px`, поскольку в этом случае элемент `span` блочный из-за `position: absolute`.

</details>

---

<a id="31"></a>

## Какое вычисленное значение будет для свойства display?

```css
span {
  display: inline-block;
  position: relative;
}
```

<details>
<summary>Ответ</summary>

`inline-block`, т.к. при `position: relative`, браузер не изменяет значение свойства `display`.

</details>

---

<a id="32"></a>

## Какие размеры у элемента span?

```css
span {
  width: 300px;
  height: 300px;
  display: flex;
}
```

<details>
<summary>Ответ</summary>

Когда к элементу применяется `display: flex`, то он становится блочным элементом, поэтому свойства `width` и `height` применятся для элемента span. Размер элемента — `300x300px`.

</details>

---

<a id="33"></a>

## В следующем примере у элемента .child вычисленное значение свойства display будет inline-block. Да или нет?

```html
<div class="parent">
  <span class="child">element2</span>
</div>
```

```css
.parent {
  display: flex;
}

.child {
  display: inline-block;
}
```

<details>
<summary>Ответ</summary>

Нет. Внутри флекс-контейнера элементы становятся блочными, поэтому вычисленное значение — `block`.

</details>

---

<a id="34"></a>

## Какой отступ будет между элементами?

```html
<body>
  <div class="parent">
    <div class="first-child">element 1</div>
    <div class="second-child">element 2</div>
  </div>
</body>
```

```css
.parent {
  display: flex;
  flex-direction: column;
}

.first-child {
  margin-bottom: 20px;
}

.second-child {
  margin-top: 10px;
}
```

<details>
<summary>Ответ</summary>

`30px`, потому что `margin` внутри флекс-контейнера не схлопываются.

</details>

---

<a id="35"></a>

## Где будет располагаться элемент .child относительно краев родительского элемента?

```html
<div class="parent">
  <span class="child">element2</span>
</div>
```

```css
.parent {
  display: flex;
  width: 250px;
  height: 250px;
}

.child {
  width: 100px;
  height: 100px;
  margin-top: auto;
  margin-left: auto;
}
```

<details>
<summary>Ответ</summary>

В правом нижнем углу на расстоянии `150px`.

</details>

---

<a id="35"></a>

## Какие размеры у элемента span?

```html
<div class="parent">
  <span class="child">element2</span>
</div>
```

```css
.parent {
  display: flex;
}

.child {
  flex-basis: 250px;
  width: 100px;
  height: 200px;
  min-width: 150px;
  max-width: 225px;
}
```

<details>
<summary>Ответ</summary>

`225px`. У свойства `flex-basis` есть приоритет перед свойством `width`, но также его значение должно быть в диапазоне значений свойств `min-width` и `max-width`. В нашем случае `250px` (`flex-basis`) не укладывается в диапазон, и поэтому значение ширины ограничивается `225px`.

</details>

---

<a id="36"></a>

## Разница между display: none и visibility: hidden?

`visibility: hidden` скрывает содержимое тега, но оставляет элемент в обычном потоке страницы таким образом, что он по-прежнему занимает место. `display: none` полностью удаляет элемент из документа. Он не занимает места, хотя всё ещё находится в исходном HTML-коде.

---

<a id="37"></a>

## Что такое блочная модель CSS?

Блочная модель — правила, по которым браузер определяет размер элемента на странице, его ширину и высоту. В этом уроке рассмотрим все правила, которые влияют на блочную модель и научимся менять саму логику расчета размеров элемента.

- [Блочная модель CSS](https://ru.hexlet.io/courses/css-content/lessons/box-model/theory_unit)

---

<a id="38"></a>

## Типы позиционирования в CSS?

Значения `position`:

1. `static` — значение по умолчанию, элемент позиционируется в соответствии с его местом в потоке документа;
2. `relative` — элемент позиционируется относительно своего исходного положения в потоке документа;
3. `absolute` — элемент позиционируется относительно ближайшего родительского элемента, который имеет позиционирование, отличное от static;
4. `fixed` — элемент позиционируется относительно окна браузера;
5. `sticky` — элемент остаётся на месте при прокрутке страницы, но при этом может быть отодвинут от своей стандартной позиции.

- [Как позиционировать элементы в CSS. Свойство position](https://htmlacademy.ru/blog/css/position)

---

<a id="39"></a>

## Разница между margin и padding?

Падинги (свойство `padding`) — это внутренние отступы от границ элемента до его содержимого. Маржины (свойство `margin`) — это внешние отступы от границ элемента до соседних элементов.

---

<a id="40"></a>

## Что такое схлопывание границ (margin collapsing)?

Отступы `margin-top` и `margin-bottom` иногда объединяются в один, с размером равным наибольшему из них (или размеру одного, если они равны). Это поведение известно как схлопывание внешних отступов (`margin collapsing`). Обратите внимание, что отступы плавающих и абсолютно позиционированных элементов никогда не схлопываются.

- [Схлопывание внешних отступов](https://developer.mozilla.org/ru/docs/Web/CSS/CSS_box_model/Mastering_margin_collapsing)

---

<a id="41"></a>

## Что такое z-index? Как формируется контекст наложения?

Контекст наложения — набор правил, на основании которых браузер решает, какой элемент на странице будет выше или ниже других. Условно, если представлять элементы как колоду карт, то правила формирования контекста наложения тасуют колоду. Это одна из основных концепций `CSS`.

Но мы можем не подчиняться стандартным правилам браузера и устанавливать свой порядок наложения элементов друг на друга. Для этого понадобится свойство `z-index`.

- [Контекст наложения](https://doka.guide/css/stacking-context/)

---

<a id="42"></a>

## Какой селектор позволяет стилизовать родителя при наличии конкретного ребёнка?

`:has()` - Уникальный селектор, позволяющий стилизовать родителя при наличии конкретного ребёнка.

Функция-псевдокласс `:has()` позволяет уточнить основной селектор дополнительным. Это единственный способ выбрать элемент на основе дочернего или соседнего элемента посредством CSS.

- [Дока :has()](https://doka.guide/css/has/)

---

<a id="43"></a>

## Как сделать приложение responsive?

Создание responsive-приложения (адаптивного интерфейса) позволяет ему корректно отображаться на устройствах с разными размерами экранов, от мобильных телефонов до десктопов.

- [Отзывчивый дизайн](https://developer.mozilla.org/ru/docs/Learn_web_development/Core/CSS_layout/Responsive_Design)
- [Адаптивная вёрстка: что это и как использовать](https://tproger.ru/translations/responsive-web-design-tips)

---

<a id="44"></a>

## Зачем нужны префиксы для некоторых CSS-свойств (-webkit-, -moz- и т. д.)?

Вендорные префиксы в `CSS`, такие как `-webkit-`, `-moz-`, `-ms-` и `-o-`, используются для обеспечения поддержки экспериментальных или ещё не стандартизированных свойств в различных браузерах.

Зачем нужны префиксы?

1. Экспериментальные функции: Когда браузеры внедряют новые CSS-свойства, они могут использовать префиксы, чтобы разработчики могли опробовать эти функции до их официального утверждения в стандартах.

2. Кроссбраузерная совместимость: Поскольку разные браузеры могут по-разному реализовывать новые свойства, префиксы помогают избежать конфликтов и обеспечивают корректную работу стилей в конкретном браузере.

- [CSS свойства — устаревшие и новые. Вендорные префиксы. Директива @supports. Сервис caniuse](https://www.youtube.com/watch?v=5JrU-SM-200)

---

<a id="45"></a>

## Какие способы центрирования блочного контента по горизонтали и вертикали знаете?

1. `Flexbox`
2. `Grid Layout`
3. Использование абсолютного позиционирования
4. `text-align` и `line-height`
5. Через автоотступы

- [Центрирование горизонтальное и вертикальное](https://learn.javascript.ru/css-center)
- [Выравнивание по центру в CSS: приёмы, свойства, подводные камни](https://skillbox.ru/media/code/vyravnivanie-po-tsentru-v-css-priyemy-svoystva-podvodnye-kamni)

---

[На главную](../README.md)
